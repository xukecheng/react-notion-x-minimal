{"version":3,"file":"react-hotkeys-hook.cjs.production.min.js","sources":["../src/useHotkeys.ts","../src/useIsHotkeyPressed.ts"],"sourcesContent":["import hotkeys, { HotkeysEvent, KeyHandler } from 'hotkeys-js';\nimport React, { useCallback, useEffect, useRef } from 'react';\n\ntype AvailableTags = 'INPUT' | 'TEXTAREA' | 'SELECT';\n\n// We implement our own custom filter system.\nhotkeys.filter = () => true;\n\nconst tagFilter = ({ target, srcElement }: KeyboardEvent, enableOnTags?: AvailableTags[]) => {\n  // @ts-ignore\n  const targetTagName = (target && target.tagName) || (srcElement && srcElement.tagName);\n\n  return Boolean(targetTagName && enableOnTags && enableOnTags.includes(targetTagName as AvailableTags));\n};\n\nconst isKeyboardEventTriggeredByInput = (ev: KeyboardEvent) => {\n  return tagFilter(ev, ['INPUT', 'TEXTAREA', 'SELECT']);\n};\n\nexport type Options = {\n  filter?: typeof hotkeys.filter;\n  filterPreventDefault?: boolean;\n  enableOnTags?: AvailableTags[];\n  splitKey?: string;\n  scope?: string;\n  keyup?: boolean;\n  keydown?: boolean;\n};\n\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: Options, deps?: any[]): React.MutableRefObject<T | null>;\nexport function useHotkeys<T extends Element>(keys: string, callback: KeyHandler, options?: any[] | Options, deps?: any[]): React.MutableRefObject<T | null> {\n  if (options instanceof Array) {\n    deps = options;\n    options = undefined;\n  }\n\n  const { enableOnTags, filter, keyup, keydown, filterPreventDefault = true } = options || {};\n  const ref = useRef<T | null>(null);\n\n  const memoisedCallback = useCallback((keyboardEvent: KeyboardEvent, hotkeysEvent: HotkeysEvent) => {\n    if (filter && !filter(keyboardEvent)) {\n      return !filterPreventDefault;\n    }\n\n    if (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags)) {\n      return true;\n    }\n\n    if (ref.current === null || document.activeElement === ref.current) {\n      callback(keyboardEvent, hotkeysEvent);\n      return true;\n    }\n\n    return false;\n  }, deps ? [ref, enableOnTags, filter, ...deps] : [ref, enableOnTags, filter]);\n\n  useEffect(() => {\n    if (keyup && keydown !== true) {\n      (options as Options).keydown = false;\n    }\n\n    hotkeys(keys, (options as Options) || {}, memoisedCallback);\n\n    return () => hotkeys.unbind(keys, memoisedCallback);\n  }, [memoisedCallback, options, keys]);\n\n  return ref;\n}","import hotkeys from 'hotkeys-js';\n\nexport function useIsHotkeyPressed() {\n  return hotkeys.isPressed;\n}"],"names":["hotkeys","filter","tagFilter","enableOnTags","target","srcElement","targetTagName","tagName","Boolean","includes","keys","callback","options","deps","Array","undefined","keyup","keydown","filterPreventDefault","ref","useRef","memoisedCallback","useCallback","keyboardEvent","hotkeysEvent","current","document","activeElement","useEffect","unbind","isPressed"],"mappings":"iHAMAA,EAAQC,OAAS,kBAAM,GAEvB,IAAMC,EAAY,WAAwCC,OAArCC,IAAAA,OAAQC,IAAAA,WAErBC,EAAiBF,GAAUA,EAAOG,SAAaF,GAAcA,EAAWE,eAEvEC,QAAQF,GAAiBH,GAAgBA,EAAaM,SAASH,wBAoBxE,SAA8CI,EAAcC,EAAsBC,EAA2BC,GACvGD,aAAmBE,QACrBD,EAAOD,EACPA,OAAUG,SAGkEH,GAAW,GAAjFT,IAAAA,aAAcF,IAAAA,OAAQe,IAAAA,MAAOC,IAAAA,YAASC,qBAAAA,gBACxCC,EAAMC,SAAiB,MAEvBC,EAAmBC,eAAY,SAACC,EAA8BC,UAC9DvB,IAAWA,EAAOsB,IACZL,KA3BLhB,EA8B+BqB,EA9BjB,CAAC,QAAS,WAAY,YA8BcrB,EAAUqB,EAAepB,MAI5D,OAAhBgB,EAAIM,SAAoBC,SAASC,gBAAkBR,EAAIM,WACzDd,EAASY,EAAeC,IACjB,KAIRX,GAAQM,EAAKhB,EAAcF,UAAWY,GAAQ,CAACM,EAAKhB,EAAcF,WAErE2B,aAAU,kBACJZ,IAAqB,IAAZC,IACVL,EAAoBK,SAAU,GAGjCjB,EAAQU,EAAOE,GAAuB,GAAIS,GAEnC,kBAAMrB,EAAQ6B,OAAOnB,EAAMW,MACjC,CAACA,EAAkBT,EAASF,IAExBS,gDCjEAnB,EAAQ8B"}