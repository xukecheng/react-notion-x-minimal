{"version":3,"sources":["../src/notion-api.ts"],"sourcesContent":["// import { promises as fs } from 'fs'\nimport got, { OptionsOfJSONResponseBody } from 'got'\nimport pMap from 'p-map'\n\nimport {\n  parsePageId,\n  getPageContentBlockIds,\n  uuidToId,\n  getBlockCollectionId\n} from 'notion-utils'\nimport * as notion from 'notion-types'\n\nimport * as types from './types'\n\n/**\n * Main Notion API client.\n */\nexport class NotionAPI {\n  private readonly _apiBaseUrl: string\n  private readonly _authToken?: string\n  private readonly _activeUser?: string\n  private readonly _userTimeZone: string\n\n  constructor({\n    apiBaseUrl = 'https://www.notion.so/api/v3',\n    authToken,\n    activeUser,\n    userTimeZone = 'America/New_York'\n  }: {\n    apiBaseUrl?: string\n    authToken?: string\n    userLocale?: string\n    userTimeZone?: string\n    activeUser?: string\n  } = {}) {\n    this._apiBaseUrl = apiBaseUrl\n    this._authToken = authToken\n    this._activeUser = activeUser\n    this._userTimeZone = userTimeZone\n  }\n\n  public async getPage(\n    pageId: string,\n    {\n      concurrency = 3,\n      fetchMissingBlocks = true,\n      fetchCollections = true,\n      signFileUrls = true,\n      chunkLimit = 100,\n      chunkNumber = 0,\n      gotOptions\n    }: {\n      concurrency?: number\n      fetchMissingBlocks?: boolean\n      fetchCollections?: boolean\n      signFileUrls?: boolean\n      chunkLimit?: number\n      chunkNumber?: number\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ): Promise<notion.ExtendedRecordMap> {\n    const page = await this.getPageRaw(pageId, {\n      chunkLimit,\n      chunkNumber,\n      gotOptions\n    })\n    const recordMap = page?.recordMap as notion.ExtendedRecordMap\n\n    if (!recordMap?.block) {\n      throw new Error(`Notion page not found \"${uuidToId(pageId)}\"`)\n    }\n\n    // ensure that all top-level maps exist\n    recordMap.collection = recordMap.collection ?? {}\n    recordMap.collection_view = recordMap.collection_view ?? {}\n    recordMap.notion_user = recordMap.notion_user ?? {}\n\n    // additional mappings added for convenience\n    // note: these are not native notion objects\n    recordMap.collection_query = {}\n    recordMap.signed_urls = {}\n\n    if (fetchMissingBlocks) {\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        // fetch any missing content blocks\n        const pendingBlockIds = getPageContentBlockIds(recordMap).filter(\n          (id) => !recordMap.block[id]\n        )\n\n        if (!pendingBlockIds.length) {\n          break\n        }\n\n        const newBlocks = await this.getBlocks(\n          pendingBlockIds,\n          gotOptions\n        ).then((res) => res.recordMap.block)\n\n        recordMap.block = { ...recordMap.block, ...newBlocks }\n      }\n    }\n\n    const contentBlockIds = getPageContentBlockIds(recordMap)\n\n    // Optionally fetch all data for embedded collections and their associated views.\n    // NOTE: We're eagerly fetching *all* data for each collection and all of its views.\n    // This is really convenient in order to ensure that all data needed for a given\n    // Notion page is readily available for use cases involving server-side rendering\n    // and edge caching.\n    if (fetchCollections) {\n      const allCollectionInstances: Array<{\n        collectionId: string\n        collectionViewId: string\n      }> = contentBlockIds.flatMap((blockId) => {\n        const block = recordMap.block[blockId].value\n        const collectionId =\n          block &&\n          (block.type === 'collection_view' ||\n            block.type === 'collection_view_page') &&\n          getBlockCollectionId(block, recordMap)\n\n        if (collectionId) {\n          return block.view_ids?.map((collectionViewId) => ({\n            collectionId,\n            collectionViewId\n          }))\n        } else {\n          return []\n        }\n      })\n\n      // fetch data for all collection view instances\n      await pMap(\n        allCollectionInstances,\n        async (collectionInstance) => {\n          const { collectionId, collectionViewId } = collectionInstance\n          const collectionView =\n            recordMap.collection_view[collectionViewId]?.value\n\n          try {\n            const collectionData = await this.getCollectionData(\n              collectionId,\n              collectionViewId,\n              collectionView,\n              {\n                gotOptions\n              }\n            )\n\n            // await fs.writeFile(\n            //   `${collectionId}-${collectionViewId}.json`,\n            //   JSON.stringify(collectionData.result, null, 2)\n            // )\n\n            recordMap.block = {\n              ...recordMap.block,\n              ...collectionData.recordMap.block\n            }\n\n            recordMap.collection = {\n              ...recordMap.collection,\n              ...collectionData.recordMap.collection\n            }\n\n            recordMap.collection_view = {\n              ...recordMap.collection_view,\n              ...collectionData.recordMap.collection_view\n            }\n\n            recordMap.notion_user = {\n              ...recordMap.notion_user,\n              ...collectionData.recordMap.notion_user\n            }\n\n            recordMap.collection_query![collectionId] = {\n              ...recordMap.collection_query![collectionId],\n              [collectionViewId]: (collectionData.result as any)?.reducerResults\n            }\n          } catch (err) {\n            // It's possible for public pages to link to private collections, in which case\n            // Notion returns a 400 error\n            console.warn('NotionAPI collectionQuery error', pageId, err.message)\n            console.error(err)\n          }\n        },\n        {\n          concurrency\n        }\n      )\n    }\n\n    // Optionally fetch signed URLs for any embedded files.\n    // NOTE: Similar to collection data, we default to eagerly fetching signed URL info\n    // because it is preferable for many use cases as opposed to making these API calls\n    // lazily from the client-side.\n    if (signFileUrls) {\n      await this.addSignedUrls({ recordMap, contentBlockIds, gotOptions })\n    }\n\n    return recordMap\n  }\n\n  public async addSignedUrls({\n    recordMap,\n    contentBlockIds,\n    gotOptions = {}\n  }: {\n    recordMap: notion.ExtendedRecordMap\n    contentBlockIds?: string[]\n    gotOptions?: OptionsOfJSONResponseBody\n  }) {\n    recordMap.signed_urls = {}\n\n    if (!contentBlockIds) {\n      contentBlockIds = getPageContentBlockIds(recordMap)\n    }\n\n    const allFileInstances = contentBlockIds.flatMap((blockId) => {\n      const block = recordMap.block[blockId].value\n\n      if (\n        block &&\n        (block.type === 'pdf' ||\n          block.type === 'audio' ||\n          (block.type === 'image' && block.file_ids?.length) ||\n          block.type === 'video' ||\n          block.type === 'file' ||\n          block.type === 'page')\n      ) {\n        const source =\n          block.type === 'page'\n            ? block.format?.page_cover\n            : block.properties?.source?.[0]?.[0]\n        // console.log(block, source)\n\n        if (source) {\n          if (source.indexOf('youtube') >= 0 || source.indexOf('vimeo') >= 0) {\n            return []\n          }\n\n          return {\n            permissionRecord: {\n              table: 'block',\n              id: block.id\n            },\n            url: source\n          }\n        }\n      }\n\n      return []\n    })\n\n    if (allFileInstances.length > 0) {\n      try {\n        const { signedUrls } = await this.getSignedFileUrls(\n          allFileInstances,\n          gotOptions\n        )\n\n        if (signedUrls.length === allFileInstances.length) {\n          for (let i = 0; i < allFileInstances.length; ++i) {\n            const file = allFileInstances[i]\n            const signedUrl = signedUrls[i]\n\n            recordMap.signed_urls[file.permissionRecord.id] = signedUrl\n          }\n        }\n      } catch (err) {\n        console.warn('NotionAPI getSignedfileUrls error', err)\n      }\n    }\n  }\n\n  public async getPageRaw(\n    pageId: string,\n    {\n      gotOptions,\n      chunkLimit = 100,\n      chunkNumber = 0\n    }: {\n      chunkLimit?: number\n      chunkNumber?: number\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ) {\n    const parsedPageId = parsePageId(pageId)\n\n    if (!parsedPageId) {\n      throw new Error(`invalid notion pageId \"${pageId}\"`)\n    }\n\n    const body = {\n      pageId: parsedPageId,\n      limit: chunkLimit,\n      chunkNumber: chunkNumber,\n      cursor: { stack: [] },\n      verticalColumns: false\n    }\n\n    return this.fetch<notion.PageChunk>({\n      endpoint: 'loadPageChunk',\n      body,\n      gotOptions\n    })\n  }\n\n  public async getCollectionData(\n    collectionId: string,\n    collectionViewId: string,\n    collectionView: any,\n    {\n      limit = 9999,\n      searchQuery = '',\n      userTimeZone = this._userTimeZone,\n      loadContentCover = true,\n      gotOptions\n    }: {\n      type?: notion.CollectionViewType\n      limit?: number\n      searchQuery?: string\n      userTimeZone?: string\n      userLocale?: string\n      loadContentCover?: boolean\n      gotOptions?: OptionsOfJSONResponseBody\n    } = {}\n  ) {\n    const type = collectionView?.type\n    const isBoardType = type === 'board'\n    const groupBy =\n      collectionView?.format?.board_columns_by ||\n      collectionView?.format?.collection_group_by\n\n    let loader: any = {\n      type: 'reducer',\n      reducers: {\n        collection_group_results: {\n          type: 'results',\n          limit,\n          loadContentCover\n        }\n      },\n      sort: [],\n      ...collectionView?.query2,\n      searchQuery,\n      userTimeZone\n    }\n\n    if (groupBy) {\n      const groups =\n        collectionView?.format?.board_columns ||\n        collectionView?.format?.collection_groups ||\n        []\n      const iterators = [isBoardType ? 'board' : 'group_aggregation', 'results']\n      const operators = {\n        checkbox: 'checkbox_is',\n        url: 'string_starts_with',\n        text: 'string_starts_with',\n        select: 'enum_is',\n        multi_select: 'enum_contains',\n        created_time: 'date_is_within',\n        ['undefined']: 'is_empty'\n      }\n\n      const reducersQuery = {}\n      for (const group of groups) {\n        const {\n          property,\n          value: { value, type }\n        } = group\n\n        for (const iterator of iterators) {\n          const iteratorProps =\n            iterator === 'results'\n              ? {\n                  type: iterator,\n                  limit\n                }\n              : {\n                  type: 'aggregation',\n                  aggregation: {\n                    aggregator: 'count'\n                  }\n                }\n\n          const isUncategorizedValue = typeof value === 'undefined'\n          const isDateValue = value?.range\n          // TODO: review dates reducers\n          const queryLabel = isUncategorizedValue\n            ? 'uncategorized'\n            : isDateValue\n            ? value.range?.start_date || value.range?.end_date\n            : value?.value || value\n\n          const queryValue =\n            !isUncategorizedValue && (isDateValue || value?.value || value)\n\n          reducersQuery[`${iterator}:${type}:${queryLabel}`] = {\n            ...iteratorProps,\n            filter: {\n              operator: 'and',\n              filters: [\n                {\n                  property,\n                  filter: {\n                    operator: !isUncategorizedValue\n                      ? operators[type]\n                      : 'is_empty',\n                    ...(!isUncategorizedValue && {\n                      value: {\n                        type: 'exact',\n                        value: queryValue\n                      }\n                    })\n                  }\n                }\n              ]\n            }\n          }\n        }\n      }\n\n      //TODO: started working on the filters. This doens't seem to quite work yet.\n      // let filters = collectionView.format?.property_filters.map(filterObj => {\n      //   console.log('map filter', filterObj)\n      //   //get the inner filter\n      //   return {\n      //     filter: filterObj.filter.filter,\n      //     property: filterObj.filter.property\n      //   }\n      // })\n\n      const reducerLabel = isBoardType ? 'board_columns' : `${type}_groups`\n      loader = {\n        type: 'reducer',\n        reducers: {\n          [reducerLabel]: {\n            type: 'groups',\n            groupBy,\n            ...(collectionView?.query2?.filter && {\n              filter: collectionView?.query2?.filter\n            }),\n            groupSortPreference: groups.map((group) => group?.value),\n            limit\n          },\n          ...reducersQuery\n        },\n        ...collectionView?.query2,\n        searchQuery,\n        userTimeZone\n        //TODO: add filters here\n        // filter: {\n        //   filters: filters,\n        //   operator: 'and'\n        // }\n      }\n    }\n\n    // if (isBoardType) {\n    //   console.log(\n    //     JSON.stringify(\n    //       {\n    //         collectionId,\n    //         collectionViewId,\n    //         loader,\n    //         groupBy: groupBy || 'NONE',\n    //         collectionViewQuery: collectionView.query2 || 'NONE'\n    //       },\n    //       null,\n    //       2\n    //     )\n    //   )\n    // }\n\n    return this.fetch<notion.CollectionInstance>({\n      endpoint: 'queryCollection',\n      body: {\n        collection: {\n          id: collectionId\n        },\n        collectionView: {\n          id: collectionViewId\n        },\n        loader\n      },\n      gotOptions\n    })\n  }\n\n  public async getUsers(\n    userIds: string[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<notion.RecordValues<notion.User>>({\n      endpoint: 'getRecordValues',\n      body: {\n        requests: userIds.map((id) => ({ id, table: 'notion_user' }))\n      },\n      gotOptions\n    })\n  }\n\n  public async getBlocks(\n    blockIds: string[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<notion.PageChunk>({\n      endpoint: 'syncRecordValues',\n      body: {\n        requests: blockIds.map((blockId) => ({\n          // TODO: when to use table 'space' vs 'block'?\n          table: 'block',\n          id: blockId,\n          version: -1\n        }))\n      },\n      gotOptions\n    })\n  }\n\n  public async getSignedFileUrls(\n    urls: types.SignedUrlRequest[],\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    return this.fetch<types.SignedUrlResponse>({\n      endpoint: 'getSignedFileUrls',\n      body: {\n        urls\n      },\n      gotOptions\n    })\n  }\n\n  public async search(\n    params: notion.SearchParams,\n    gotOptions?: OptionsOfJSONResponseBody\n  ) {\n    const body = {\n      type: 'BlocksInAncestor',\n      source: 'quick_find_public',\n      ancestorId: parsePageId(params.ancestorId),\n      sort: 'Relevance',\n      limit: params.limit || 20,\n      query: params.query,\n      filters: {\n        isDeletedOnly: false,\n        isNavigableOnly: false,\n        excludeTemplates: true,\n        requireEditPermissions: false,\n        ancestors: [],\n        createdBy: [],\n        editedBy: [],\n        lastEditedTime: {},\n        createdTime: {},\n        ...params.filters\n      }\n    }\n\n    return this.fetch<notion.SearchResults>({\n      endpoint: 'search',\n      body,\n      gotOptions\n    })\n  }\n\n  public async fetch<T>({\n    endpoint,\n    body,\n    gotOptions,\n    headers: clientHeaders\n  }: {\n    endpoint: string\n    body: object\n    gotOptions?: OptionsOfJSONResponseBody\n    headers?: any\n  }): Promise<T> {\n    const headers: any = {\n      ...clientHeaders,\n      ...gotOptions?.headers,\n      'Content-Type': 'application/json'\n    }\n\n    if (this._authToken) {\n      headers.cookie = `token_v2=${this._authToken}`\n    }\n\n    if (this._activeUser) {\n      headers['x-notion-active-user-header'] = this._activeUser\n    }\n\n    const url = `${this._apiBaseUrl}/${endpoint}`\n\n    return got\n      .post(url, {\n        ...gotOptions,\n        json: body,\n        headers\n      })\n      .json()\n\n    // return fetch(url, {\n    //   method: 'post',\n    //   body: JSON.stringify(body),\n    //   headers\n    // }).then((res) => {\n    //   console.log(endpoint, res)\n    //   return res.json()\n    // })\n  }\n}\n"],"mappings":"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","names":[]}