{"version":3,"sources":["../src/get-text-content.ts","../src/get-block-collection-id.ts","../src/get-block-title.ts","../src/get-block-icon.ts","../src/get-page-title.ts","../src/get-page-property.ts","../src/get-date-value.ts","../src/get-block-parent-page.ts","../src/get-page-table-of-contents.ts","../src/get-page-content-block-ids.ts","../src/id-to-uuid.ts","../src/parse-page-id.ts","../src/uuid-to-id.ts","../src/get-all-pages-in-space.ts","../src/normalize-title.ts","../src/get-canonical-page-id.ts","../src/get-page-breadcrumbs.ts","../src/is-url.ts","../src/get-page-image-urls.ts","../src/normalize-url.ts","../src/merge-record-maps.ts","../src/format-date.ts","../src/format-notion-date-time.ts","../src/estimate-page-read-time.ts"],"sourcesContent":["import * as types from 'notion-types'\n\n/**\n * Gets the raw, unformatted text content of a block's content value.\n *\n * This is useful, for instance, for extracting a block's `title` without any\n * rich text formatting.\n */\nexport const getTextContent = (text?: types.Decoration[]): string => {\n  if (!text) {\n    return ''\n  } else if (Array.isArray(text)) {\n    return (\n      text?.reduce(\n        (prev, current) =>\n          prev + (current[0] !== '⁍' && current[0] !== '‣' ? current[0] : ''),\n        ''\n      ) ?? ''\n    )\n  } else {\n    return text\n  }\n}\n","import { Block, ExtendedRecordMap } from 'notion-types'\n\nexport function getBlockCollectionId(\n  block: Block,\n  recordMap: ExtendedRecordMap\n): string | null {\n  const collectionId =\n    (block as any).collection_id ||\n    (block as any).format?.collection_pointer?.id\n\n  if (collectionId) {\n    return collectionId\n  }\n\n  const collectionViewId = (block as any)?.view_ids?.[0]\n  if (collectionViewId) {\n    const collectionView = recordMap.collection_view?.[collectionViewId]?.value\n    if (collectionView) {\n      const collectionId = collectionView.format?.collection_pointer?.id\n      return collectionId\n    }\n  }\n\n  return null\n}\n","import { Block, ExtendedRecordMap } from 'notion-types'\nimport { getBlockCollectionId } from './get-block-collection-id'\nimport { getTextContent } from './get-text-content'\n\nexport function getBlockTitle(block: Block, recordMap: ExtendedRecordMap) {\n  if (block.properties?.title) {\n    return getTextContent(block.properties.title)\n  }\n\n  if (\n    block.type === 'collection_view_page' ||\n    block.type === 'collection_view'\n  ) {\n    const collectionId = getBlockCollectionId(block, recordMap)\n\n    if (collectionId) {\n      const collection = recordMap.collection[collectionId]?.value\n\n      if (collection) {\n        return getTextContent(collection.name)\n      }\n    }\n  }\n\n  return ''\n}\n","import { Block, PageBlock, ExtendedRecordMap } from 'notion-types'\nimport { getBlockCollectionId } from './get-block-collection-id'\n\nexport function getBlockIcon(block: Block, recordMap: ExtendedRecordMap) {\n  if ((block as PageBlock).format?.page_icon) {\n    return (block as PageBlock).format?.page_icon\n  }\n\n  if (\n    block.type === 'collection_view_page' ||\n    block.type === 'collection_view'\n  ) {\n    const collectionId = getBlockCollectionId(block, recordMap)\n    if (collectionId) {\n      const collection = recordMap.collection[collectionId]?.value\n\n      if (collection) {\n        return collection.icon\n      }\n    }\n  }\n\n  return null\n}\n","import { ExtendedRecordMap } from 'notion-types'\nimport { getBlockTitle } from './get-block-title'\n\nexport function getPageTitle(recordMap: ExtendedRecordMap) {\n  const pageBlock = recordMap.block[Object.keys(recordMap.block)[0]]?.value\n\n  if (pageBlock) {\n    return getBlockTitle(pageBlock, recordMap)\n  }\n\n  return null\n}\n","import { Block, DateFormat, ExtendedRecordMap } from 'notion-types'\nimport { getTextContent } from './get-text-content'\n\n/**\n * Gets the value of a collection property for a given page (collection item).\n *\n * @param propertyName property name\n * @param block Page block, often be first block in blockMap\n * @param recordMap\n * @returns - The return value types will follow the following principles:\n *  1. if property is date type, it will return `number` or `number[]`(depends on `End Date` switch)\n *  2. property is text-like will return `string`\n *  3. multi select property will return `string[]`\n *  4. checkbox property return `boolean`\n * @todo complete all no-text property type\n */\nexport function getPageProperty<\n  T = string | number | boolean | string[] | number[]\n>(propertyName: string, block: Block, recordMap: ExtendedRecordMap): T\nexport function getPageProperty(\n  propertyName: string,\n  block: Block,\n  recordMap: ExtendedRecordMap\n) {\n  try {\n    if (!block.properties || !Object.keys(recordMap.collection)) {\n      // console.warn(\n      //   `block ${block.id} has no properties or this recordMap has no collection record`\n      // )\n      return null\n    }\n\n    const collection = recordMap.collection[block.parent_id]?.value\n\n    if (collection) {\n      const propertyNameL = propertyName.toLowerCase()\n      const propertyId = Object.keys(collection.schema).find(\n        (key) => collection.schema[key]?.name?.toLowerCase() === propertyNameL\n      )\n\n      if (!propertyId) {\n        return null\n      }\n\n      const { type } = collection.schema[propertyId]\n      const content = getTextContent(block.properties[propertyId])\n\n      switch (type) {\n        case 'created_time':\n          return block.created_time\n\n        case 'multi_select':\n          return content.split(',')\n\n        case 'date': {\n          const property = block.properties[propertyId] as [['‣', [DateFormat]]]\n          const formatDate = property[0][1][0][1]\n\n          if (formatDate.type == 'datetime') {\n            return new Date(\n              `${formatDate.start_date} ${formatDate.start_time}`\n            ).getTime()\n          } else if (formatDate.type == 'date') {\n            return new Date(formatDate.start_date).getTime()\n          } else if (formatDate.type == 'datetimerange') {\n            const { start_date, start_time, end_date, end_time } = formatDate\n            const startTime = new Date(`${start_date} ${start_time}`).getTime()\n            const endTime = new Date(`${end_date} ${end_time}`).getTime()\n            return [startTime, endTime]\n          } else {\n            const startTime = new Date(formatDate.start_date).getTime()\n            const endTime = new Date(formatDate.end_date).getTime()\n            return [startTime, endTime]\n          }\n        }\n\n        case 'checkbox':\n          return content == 'Yes'\n\n        case 'last_edited_time':\n          return block.last_edited_time\n\n        default:\n          return content\n      }\n    }\n  } catch {\n    // ensure that no matter what, we don't throw errors because of an unexpected\n    // collection data format\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\n\n/**\n * Attempts to find a valid date from a given property.\n */\nexport const getDateValue = (prop: any[]): types.FormattedDate | null => {\n  if (prop && Array.isArray(prop)) {\n    if (prop[0] === 'd') {\n      return prop[1]\n    } else {\n      for (const v of prop) {\n        const value = getDateValue(v)\n        if (value) {\n          return value\n        }\n      }\n    }\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\n\n/**\n * Returns the parent page block containing a given page.\n *\n * Note that many times this will not be the direct parent block since\n * some non-page content blocks can contain sub-blocks.\n */\nexport const getBlockParentPage = (\n  block: types.Block,\n  recordMap: types.ExtendedRecordMap,\n  {\n    inclusive = false\n  }: {\n    inclusive?: boolean\n  } = {}\n): types.PageBlock | null => {\n  let currentRecord: types.Block | types.Collection = block\n\n  while (currentRecord != null) {\n    if (inclusive && (currentRecord as types.Block)?.type === 'page') {\n      return currentRecord as types.PageBlock\n    }\n\n    const parentId: string = currentRecord.parent_id\n    const parentTable = currentRecord.parent_table\n\n    if (!parentId) {\n      break\n    }\n\n    if (parentTable === 'collection') {\n      currentRecord = recordMap.collection[parentId]?.value\n    } else {\n      currentRecord = recordMap.block[parentId]?.value\n\n      if ((currentRecord as types.Block)?.type === 'page') {\n        return currentRecord as types.PageBlock\n      }\n    }\n  }\n\n  return null\n}\n","import * as types from 'notion-types'\nimport { getTextContent } from './get-text-content'\n\nexport interface TableOfContentsEntry {\n  id: types.ID\n  type: types.BlockType\n  text: string\n  indentLevel: number\n}\n\nconst indentLevels = {\n  header: 0,\n  sub_header: 1,\n  sub_sub_header: 2\n}\n\n/**\n * Gets the metadata for a table of contents block by parsing the page's\n * H1, H2, and H3 elements.\n */\nexport const getPageTableOfContents = (\n  page: types.PageBlock,\n  recordMap: types.ExtendedRecordMap\n): Array<TableOfContentsEntry> => {\n  const toc = (page.content ?? [])\n    .map((blockId: string) => {\n      const block = recordMap.block[blockId]?.value\n\n      if (block) {\n        const { type } = block\n\n        if (\n          type === 'header' ||\n          type === 'sub_header' ||\n          type === 'sub_sub_header'\n        ) {\n          return {\n            id: blockId,\n            type,\n            text: getTextContent(block.properties?.title),\n            indentLevel: indentLevels[type]\n          }\n        }\n      }\n\n      return null\n    })\n    .filter(Boolean) as Array<TableOfContentsEntry>\n\n  const indentLevelStack = [\n    {\n      actual: -1,\n      effective: -1\n    }\n  ]\n\n  // Adjust indent levels to always change smoothly.\n  // This is a little tricky, but the key is that when increasing indent levels,\n  // they should never jump more than one at a time.\n  for (const tocItem of toc) {\n    const { indentLevel } = tocItem\n    const actual = indentLevel\n\n    do {\n      const prevIndent = indentLevelStack[indentLevelStack.length - 1]\n      const { actual: prevActual, effective: prevEffective } = prevIndent\n\n      if (actual > prevActual) {\n        tocItem.indentLevel = prevEffective + 1\n        indentLevelStack.push({\n          actual,\n          effective: tocItem.indentLevel\n        })\n      } else if (actual === prevActual) {\n        tocItem.indentLevel = prevEffective\n        break\n      } else {\n        indentLevelStack.pop()\n      }\n\n      // eslint-disable-next-line no-constant-condition\n    } while (true)\n  }\n\n  return toc\n}\n","import * as types from 'notion-types'\n\n/**\n * Gets the IDs of all blocks contained on a page starting from a root block ID.\n */\nexport const getPageContentBlockIds = (\n  recordMap: types.ExtendedRecordMap,\n  blockId?: string\n): string[] => {\n  const rootBlockId = blockId || Object.keys(recordMap.block)[0]\n  const contentBlockIds = new Set<string>()\n\n  function addContentBlocks(blockId: string) {\n    if (contentBlockIds.has(blockId)) return\n    contentBlockIds.add(blockId)\n\n    const block = recordMap.block[blockId]?.value\n    if (!block) return\n\n    const { content, type, properties, format } = block\n    if (properties) {\n      // TODO: this needs some love, especially for resolving relation properties\n      // see this collection_view_page for an example: 8a586d253f984b85b48254da84465d23\n      for (const key of Object.keys(properties)) {\n        const p = properties[key]\n        p.map((d: any) => {\n          const value = d?.[0]?.[1]?.[0]\n          if (value?.[0] === 'p' && value[1]) {\n            addContentBlocks(value[1])\n          }\n        })\n\n        // [[\"‣\", [[\"p\", \"841918aa-f2a3-4d4c-b5ad-64b0f57c47b8\"]]]]\n        const value = p?.[0]?.[1]?.[0]\n\n        if (value?.[0] === 'p' && value[1]) {\n          addContentBlocks(value[1])\n        }\n      }\n    }\n\n    if (format) {\n      const referenceId = format.transclusion_reference_pointer?.id\n      if (referenceId) {\n        addContentBlocks(referenceId)\n      }\n    }\n\n    if (!content || !Array.isArray(content)) {\n      // no child content blocks to recurse on\n      return\n    }\n\n    if (blockId !== rootBlockId) {\n      if (type === 'page' || type === 'collection_view_page') {\n        // ignore the content of other pages and collections\n        return\n      }\n    }\n\n    for (const blockId of content) {\n      addContentBlocks(blockId)\n    }\n  }\n\n  addContentBlocks(rootBlockId)\n  return Array.from(contentBlockIds)\n}\n","export const idToUuid = (id = '') =>\n  `${id.substr(0, 8)}-${id.substr(8, 4)}-${id.substr(12, 4)}-${id.substr(\n    16,\n    4\n  )}-${id.substr(20)}`\n","import { idToUuid } from './id-to-uuid'\n\nconst pageIdRe = /\\b([a-f0-9]{32})\\b/\nconst pageId2Re =\n  /\\b([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})\\b/\n\n/**\n * Robustly extracts the notion page ID from a notion URL or pathname suffix.\n *\n * Defaults to returning a UUID (with dashes).\n */\nexport const parsePageId = (\n  id: string | null = '',\n  { uuid = true }: { uuid?: boolean } = {}\n) => {\n  if (!id) {\n    return null\n  }\n\n  id = id.split('?')[0]\n  const match = id.match(pageIdRe)\n\n  if (match) {\n    return uuid ? idToUuid(match[1]) : match[1]\n  }\n\n  const match2 = id.match(pageId2Re)\n  if (match2) {\n    return uuid ? match2[1] : match2[1].replace(/-/g, '')\n  }\n\n  return null\n}\n","export const uuidToId = (uuid: string) => uuid.replace(/-/g, '')\n","import PQueue from 'p-queue'\n\nimport { ExtendedRecordMap, PageMap } from 'notion-types'\nimport { parsePageId } from './parse-page-id'\n\n/**\n * Performs a traversal over a given Notion workspace starting from a seed page.\n *\n * Returns a map containing all of the pages that are reachable from the seed\n * page in the space.\n *\n * If `rootSpaceId` is not defined, the space ID of the root page will be used\n * to scope traversal.\n *\n *\n * @param rootPageId - Page ID to start from.\n * @param rootSpaceId - Space ID to scope traversal.\n * @param getPage - Function used to fetch a single page.\n * @param opts - Optional config\n */\nexport async function getAllPagesInSpace(\n  rootPageId: string,\n  rootSpaceId: string | undefined,\n  getPage: (pageId: string) => Promise<ExtendedRecordMap>,\n  {\n    concurrency = 4,\n    traverseCollections = true,\n    targetPageId = null\n  }: {\n    concurrency?: number\n    traverseCollections?: boolean\n    targetPageId?: string\n  } = {}\n): Promise<PageMap> {\n  const pages: PageMap = {}\n  const pendingPageIds = new Set<string>()\n  const queue = new PQueue({ concurrency })\n\n  async function processPage(pageId: string) {\n    if (targetPageId && pendingPageIds.has(targetPageId)) {\n      return\n    }\n\n    pageId = parsePageId(pageId) as string\n\n    if (pageId && !pages[pageId] && !pendingPageIds.has(pageId)) {\n      pendingPageIds.add(pageId)\n\n      queue.add(async () => {\n        try {\n          if (\n            targetPageId &&\n            pendingPageIds.has(targetPageId) &&\n            pageId !== targetPageId\n          ) {\n            return\n          }\n\n          const page = await getPage(pageId)\n          if (!page) {\n            return\n          }\n\n          const spaceId = page.block[pageId]?.value?.space_id\n\n          if (spaceId) {\n            if (!rootSpaceId) {\n              rootSpaceId = spaceId\n            } else if (rootSpaceId !== spaceId) {\n              return\n            }\n          }\n\n          Object.keys(page.block)\n            .filter((key) => {\n              const block = page.block[key]?.value\n              if (!block) return false\n\n              if (\n                block.type !== 'page' &&\n                block.type !== 'collection_view_page'\n              ) {\n                return false\n              }\n\n              // the space id check is important to limit traversal because pages\n              // can reference pages in other spaces\n              if (\n                rootSpaceId &&\n                block.space_id &&\n                block.space_id !== rootSpaceId\n              ) {\n                return false\n              }\n\n              return true\n            })\n            .forEach((subPageId) => processPage(subPageId))\n\n          // traverse collection item pages as they may contain subpages as well\n          if (traverseCollections) {\n            for (const collectionViews of Object.values(\n              page.collection_query\n            )) {\n              for (const collectionData of Object.values(collectionViews)) {\n                const { blockIds } = collectionData\n\n                if (blockIds) {\n                  for (const collectionItemId of blockIds) {\n                    processPage(collectionItemId)\n                  }\n                }\n              }\n            }\n          }\n\n          pages[pageId] = page\n        } catch (err) {\n          console.warn(\n            'page load error',\n            { pageId, spaceId: rootSpaceId },\n            err.statusCode,\n            err.message\n          )\n          pages[pageId] = null\n        }\n\n        pendingPageIds.delete(pageId)\n      })\n    }\n  }\n\n  await processPage(rootPageId)\n  await queue.onIdle()\n\n  return pages\n}\n","export const normalizeTitle = (title?: string | null): string => {\n  return (title || '')\n    .replace(/ /g, '-')\n    .replace(/[^a-zA-Z0-9-\\u4e00-\\u9fa5]/g, '')\n    .replace(/--/g, '-')\n    .replace(/-$/, '')\n    .replace(/^-/, '')\n    .trim()\n    .toLowerCase()\n}\n","import { ExtendedRecordMap } from 'notion-types'\nimport { uuidToId } from './uuid-to-id'\nimport { getBlockTitle } from './get-block-title'\nimport { getPageProperty } from './get-page-property'\nimport { normalizeTitle } from './normalize-title'\n\n/**\n * Gets the canonical, display-friendly version of a page's ID for use in URLs.\n */\nexport const getCanonicalPageId = (\n  pageId: string,\n  recordMap: ExtendedRecordMap,\n  { uuid = true }: { uuid?: boolean } = {}\n): string | null => {\n  if (!pageId || !recordMap) return null\n\n  const id = uuidToId(pageId)\n  const block = recordMap.block[pageId]?.value\n\n  if (block) {\n    const slug =\n      (getPageProperty('slug', block, recordMap) as string | null) ||\n      (getPageProperty('Slug', block, recordMap) as string | null) ||\n      normalizeTitle(getBlockTitle(block, recordMap))\n\n    if (slug) {\n      if (uuid) {\n        return `${slug}-${id}`\n      } else {\n        return slug\n      }\n    }\n  }\n\n  return id\n}\n","import * as types from 'notion-types'\nimport { getBlockTitle } from './get-block-title'\nimport { getBlockIcon } from './get-block-icon'\nimport { getBlockParentPage } from './get-block-parent-page'\n\nexport const getPageBreadcrumbs = (\n  recordMap: types.ExtendedRecordMap,\n  activePageId: string\n): Array<any> | null => {\n  const blockMap = recordMap.block\n  const breadcrumbs = []\n\n  let currentPageId = activePageId\n\n  do {\n    const block = blockMap[currentPageId]?.value\n    if (!block) {\n      break\n    }\n\n    const title = getBlockTitle(block, recordMap)\n    const icon = getBlockIcon(block, recordMap)\n\n    if (!(title || icon)) {\n      break\n    }\n\n    breadcrumbs.push({\n      block,\n      active: currentPageId === activePageId,\n      pageId: currentPageId,\n      title,\n      icon\n    })\n\n    const parentBlock = getBlockParentPage(block, recordMap)\n    const parentId = parentBlock?.id\n\n    if (!parentId) {\n      break\n    }\n\n    currentPageId = parentId\n\n    // eslint-disable-next-line no-constant-condition\n  } while (true)\n\n  breadcrumbs.reverse()\n\n  return breadcrumbs\n}\n","import isUrl from 'is-url-superb'\n\nexport { isUrl }\n","import * as types from 'notion-types'\nimport { isUrl } from './is-url'\nimport { getBlockIcon } from './get-block-icon'\n\n/**\n * Gets URLs of all images contained on the given page.\n */\nexport const getPageImageUrls = (\n  recordMap: types.ExtendedRecordMap,\n  {\n    mapImageUrl\n  }: {\n    mapImageUrl: (url: string, block: types.Block) => string | null\n  }\n): string[] => {\n  const blockIds = Object.keys(recordMap.block)\n  const imageUrls: string[] = blockIds\n    .flatMap((blockId) => {\n      const block = recordMap.block[blockId]?.value\n      const images: Array<{ block: types.Block; url: string }> = []\n\n      if (block) {\n        if (block.type === 'image') {\n          const signedUrl = recordMap.signed_urls?.[block.id]\n          const source = signedUrl || block.properties?.source?.[0]?.[0]\n\n          if (source) {\n            images.push({\n              block,\n              url: source\n            })\n          }\n        }\n\n        if ((block.format as any)?.page_cover) {\n          const source = (block.format as any).page_cover\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        if ((block.format as any)?.bookmark_cover) {\n          const source = (block.format as any).bookmark_cover\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        if ((block.format as any)?.bookmark_icon) {\n          const source = (block.format as any).bookmark_icon\n\n          images.push({\n            block,\n            url: source\n          })\n        }\n\n        const pageIcon = getBlockIcon(block, recordMap)\n        if (pageIcon && isUrl(pageIcon)) {\n          images.push({\n            block,\n            url: pageIcon\n          })\n        }\n      }\n\n      return images\n    })\n    .filter(Boolean)\n    .map(({ block, url }) => mapImageUrl(url, block))\n    .filter(Boolean)\n\n  return Array.from(new Set(imageUrls))\n}\n","import normalizeUrlImpl from 'normalize-url'\nimport mem from 'mem'\n\nexport const normalizeUrl = mem((url?: string) => {\n  if (!url) {\n    return ''\n  }\n\n  try {\n    if (url.startsWith('https://www.notion.so/image/')) {\n      const u = new URL(url)\n      const subUrl = decodeURIComponent(u.pathname.substr('/image/'.length))\n      const normalizedSubUrl = normalizeUrl(subUrl)\n      u.pathname = `/image/${encodeURIComponent(normalizedSubUrl)}`\n      url = u.toString()\n    }\n\n    return normalizeUrlImpl(url, {\n      stripProtocol: true,\n      stripWWW: true,\n      stripHash: true,\n      stripTextFragment: true,\n      removeQueryParameters: true\n    })\n  } catch (err) {\n    return ''\n  }\n})\n","import { ExtendedRecordMap } from 'notion-types'\n\nexport function mergeRecordMaps(\n  recordMapA: ExtendedRecordMap,\n  recordMapB: ExtendedRecordMap\n): ExtendedRecordMap {\n  const mergedRecordMap: ExtendedRecordMap = {\n    block: {\n      ...recordMapA.block,\n      ...recordMapB.block\n    },\n    collection: {\n      ...recordMapA.collection,\n      ...recordMapB.collection\n    },\n    collection_view: {\n      ...recordMapA.collection_view,\n      ...recordMapB.collection_view\n    },\n    notion_user: {\n      ...recordMapA.notion_user,\n      ...recordMapB.notion_user\n    },\n    collection_query: {\n      ...recordMapA.collection_query,\n      ...recordMapB.collection_query\n    },\n    signed_urls: {\n      ...recordMapA.signed_urls,\n      ...recordMapB.signed_urls\n    },\n    preview_images: {\n      ...recordMapA.preview_images,\n      ...recordMapB.preview_images\n    }\n  }\n\n  return mergedRecordMap\n}\n","export const formatDate = (\n  input: string | number,\n  { month = 'short' }: { month?: 'long' | 'short' } = {}\n) => {\n  const date = new Date(input)\n  const monthLocale = date.toLocaleString('en-US', { month })\n  return `${monthLocale} ${date.getUTCDate()}, ${date.getUTCFullYear()}`\n}\n","import { formatDate } from './format-date'\n\nexport interface NotionDateTime {\n  type: 'datetime'\n  start_date: string\n  start_time?: string\n  time_zone?: string\n}\n\nexport const formatNotionDateTime = (datetime: NotionDateTime) => {\n  const dateString = `${datetime.start_time || ''} ${datetime.start_date} ${\n    datetime.time_zone || ''\n  }`\n  return formatDate(dateString)\n}\n","import { Block, ExtendedRecordMap, PageBlock } from 'notion-types'\nimport { getBlockTitle } from './get-block-title'\nimport { getPageTableOfContents } from './get-page-table-of-contents'\n\ntype EstimatePageReadTimeOptions = {\n  wordsPerMinute?: number\n  imageReadTimeInSeconds?: number\n}\n\ntype ContentStats = {\n  numWords: number\n  numImages: number\n}\n\ntype PageReadTimeEstimate = ContentStats & {\n  totalWordsReadTimeInMinutes: number\n  totalImageReadTimeInMinutes: number\n  totalReadTimeInMinutes: number\n}\n\n/**\n * Returns an estimate for the time it would take for a person to read the content\n * in the given Notion page.\n *\n * Uses Medium for inspiration.\n *\n * @see https://blog.medium.com/read-time-and-you-bc2048ab620c\n * @see https://github.com/ngryman/reading-time\n *\n * TODO: handle non-english content.\n */\nexport function estimatePageReadTime(\n  block: Block,\n  recordMap: ExtendedRecordMap,\n  {\n    wordsPerMinute = 275,\n    imageReadTimeInSeconds = 12\n  }: EstimatePageReadTimeOptions = {}\n): PageReadTimeEstimate {\n  const stats = getBlockContentStats(block, recordMap)\n  const totalWordsReadTimeInMinutes = stats.numWords / wordsPerMinute\n  const totalImageReadTimeInSeconds =\n    stats.numImages > 10\n      ? (stats.numImages / 2) * (imageReadTimeInSeconds + 3) +\n        (stats.numImages - 10) * 3 // n/2(a+b) + 3 sec/image\n      : (stats.numImages / 2) *\n        (2 * imageReadTimeInSeconds + (1 - stats.numImages)) // n/2[2a+(n-1)d]\n  const totalImageReadTimeInMinutes = totalImageReadTimeInSeconds / 60\n\n  const totalReadTimeInMinutes =\n    totalWordsReadTimeInMinutes + totalImageReadTimeInMinutes\n\n  return {\n    ...stats,\n    totalWordsReadTimeInMinutes,\n    totalImageReadTimeInMinutes,\n    totalReadTimeInMinutes\n  }\n}\n\n/**\n * Same as `estimatePageReadTime`, except it returns the total time estimate as\n * a human-readable string.\n *\n * For example, \"9 minutes\" or \"less than a minute\".\n */\nexport function estimatePageReadTimeAsHumanizedString(\n  block: Block,\n  recordMap: ExtendedRecordMap,\n  opts: EstimatePageReadTimeOptions\n) {\n  const estimate = estimatePageReadTime(block, recordMap, opts)\n  return humanizeReadTime(estimate.totalReadTimeInMinutes)\n}\n\nfunction getBlockContentStats(\n  block: Block,\n  recordMap: ExtendedRecordMap\n): ContentStats {\n  const stats: ContentStats = {\n    numWords: 0,\n    numImages: 0\n  }\n\n  if (!block) {\n    return stats\n  }\n\n  for (const childId of block.content || []) {\n    const child = recordMap.block[childId]?.value\n    let recurse = false\n    if (!child) continue\n\n    switch (child.type) {\n      case 'quote':\n      // fallthrough\n      case 'alias':\n      // fallthrough\n      case 'header':\n      // fallthrough\n      case 'sub_header':\n      // fallthrough\n      case 'sub_sub_header': {\n        const title = getBlockTitle(child, recordMap)\n        stats.numWords += countWordsInText(title)\n        break\n      }\n\n      case 'callout':\n      // fallthrough\n      case 'toggle':\n      // fallthrough\n      case 'to_do':\n      // fallthrough\n      case 'bulleted_list':\n      // fallthrough\n      case 'numbered_list':\n      // fallthrough\n      case 'text': {\n        const title = getBlockTitle(child, recordMap)\n        stats.numWords += countWordsInText(title)\n        recurse = true\n        break\n      }\n\n      case 'embed':\n      // fallthrough\n      case 'tweet':\n      // fallthrough\n      case 'maps':\n      // fallthrough\n      case 'pdf':\n      // fallthrough\n      case 'figma':\n      // fallthrough\n      case 'typeform':\n      // fallthrough\n      case 'codepen':\n      // fallthrough\n      case 'excalidraw':\n      // fallthrough\n      case 'gist':\n      // fallthrough\n      case 'video':\n      // fallthrough\n      case 'drive':\n      // fallthrough\n      case 'audio':\n      // fallthrough\n      case 'file':\n      // fallthrough\n      case 'image':\n        // treat all embeds as images\n        stats.numImages += 1\n        break\n\n      case 'bookmark':\n        // treat bookmarks as quarter images since they aren't as content-ful as embedd images\n        stats.numImages += 0.25\n        break\n\n      case 'code':\n        // treat code blocks as double the complexity of images\n        stats.numImages += 2\n        break\n\n      case 'table':\n      // fallthrough\n      case 'collection_view':\n        // treat collection views as double the complexity of images\n        stats.numImages += 2\n        break\n\n      case 'column':\n      // fallthrough\n      case 'column_list':\n      // fallthrough\n      case 'transclusion_container':\n        recurse = true\n        break\n\n      case 'table_of_contents': {\n        const page = block as PageBlock\n        if (!page) continue\n\n        const toc = getPageTableOfContents(page, recordMap)\n        for (const tocItem of toc) {\n          stats.numWords += countWordsInText(tocItem.text)\n        }\n\n        break\n      }\n\n      case 'transclusion_reference': {\n        const referencePointerId =\n          child?.format?.transclusion_reference_pointer?.id\n\n        if (!referencePointerId) {\n          continue\n        }\n        const referenceBlock = recordMap.block[referencePointerId]?.value\n        if (referenceBlock) {\n          mergeContentStats(\n            stats,\n            getBlockContentStats(referenceBlock, recordMap)\n          )\n        }\n        break\n      }\n\n      default:\n        // ignore unrecognized blocks\n        break\n    }\n\n    if (recurse) {\n      mergeContentStats(stats, getBlockContentStats(child, recordMap))\n    }\n  }\n\n  return stats\n}\n\nfunction mergeContentStats(statsA: ContentStats, statsB: ContentStats) {\n  statsA.numWords += statsB.numWords\n  statsA.numImages += statsB.numImages\n}\n\nfunction countWordsInText(text: string): number {\n  if (!text) {\n    return 0\n  }\n\n  return (text.match(/\\w+/g) || []).length\n}\n\nfunction humanizeReadTime(time: number): string {\n  if (time < 0.5) {\n    return 'less than a minute'\n  }\n\n  if (time < 1.5) {\n    return '1 minute'\n  }\n\n  return `${Math.ceil(time)} minutes`\n}\n"],"mappings":"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","names":[]}